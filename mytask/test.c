#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {

	int fd1[2], fd2[2], status; // Файловый дескриптор 0-stdi, 1-stdo, 2-stderr.
	pipe(fd1);// Cоздает канал однонаправленных данных.
	pipe(fd2);

pid_t pid2 = fork(); // Создание 2-ого процесса
	
	if (!pid2) {
        dup2(fd1[0], 0);
        
        close(fd1[0]);
        close(fd1[1]);
		
		dup2(fd2[1],1);
		
		close(fd2[0]);
        close(fd2[1]);
        
        char* command[3] = {"sort", "-nrk3", 0};
        execvp(command[0], command);
        
        exit(EXIT_FAILURE);
    } else if (pid2 == -1) {
        fprintf(stderr, "Can't fork, exiting...\n");
        exit(EXIT_FAILURE);
    }
	
	pid_t pid1 = fork(); // pid_t тип данных, который определяет идентификатор процесса.

/*
При вызове fork() порождается новый процесс (процесс-потомок), который почти идентичен порождающему процессу-родителю.
Потомок не наследует от родителя идентификатор процесса (PID, PPID).
При вызове fork() возникают два полностью идентичных процесса. Весь код после fork() выполняется дважды, как в процессе-потомке, так и в процессе-родителе.

Процесс-потомок и процесс-родитель получают разные коды возврата после вызова fork(). Процесс-родитель получает идентификатор (PID) потомка. Если это значение будет отрицательным, следовательно при порождении процесса произошла ошибка. Процесс-потомок получает в качестве кода возврата значение 0, если вызов fork() оказался успешным , если с ошибкой то -1.  
*/
	
	if (!pid1) {  // Если успешно выделяется память для описателя pid1 процесса в таблице процессов, то описываем процесс.
        dup2(fd1[1], 1); // Делает fd[1] копией 1
        
        close(fd1[0]); // Закрывает файловый дескриптор
        close(fd1[1]);
		close(fd2[0]);
        close(fd2[1]);
        
        char* command[5] = {"awk", "-f", "command.awk", "log.txt", 0}; 
        execvp(command[0], command);// Загрузка программы в системный контекст текущего процесса
/*
execvp - предоставляют процессу массив указателей на строки, заканчивающиеся null. Эти строки являются списком параметров, доступных новой программе. Первый аргумент, по соглашению, должен указать на имя, ассоциированное с файлом, который необходимо исполнить. Массив указателей должен заканчиваться NULL.
-f -  указывает что команды лежат в отдельном файле.
*/
        
        exit(EXIT_FAILURE); // Завершение процесса
    } else if (pid1 == -1) { // Если происходит ошибка при создании дочернего процесса.
        fprintf(stderr, "Can't fork, exiting...\n"); // Запись в файл ошибок.
        exit(EXIT_FAILURE);
    }
	
	
	
	pid_t pid3 = fork(); // Создание 3-его процесса
	
	if(!pid3) {

		close(fd1[0]);
        close(fd1[1]);

		dup2(fd2[0],0);

		close(fd2[0]);
        close(fd2[1]);
		
		char* command[2] = {"head", 0};
		execvp(command[0], command);
		
		exit(EXIT_FAILURE);
	} else if (pid3 == -1) {
		fprintf(stderr, "Can't fork, exiting...\n");
		exit(EXIT_FAILURE);
	}
    
    close(fd1[0]);
    close(fd1[1]);
	
	close(fd2[0]);
	close(fd2[1]);
	
	waitpid(pid1, NULL, 0); // Приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, указанный в параметре pid, не завершит выполнение
    waitpid(pid2, NULL, 0);
	waitpid(pid3, &status, 0);
	
	exit(status);
	
	return 0;
}
